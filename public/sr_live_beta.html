<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>SR コメント・ギフト 3カラム + 過去コメント補完（Render Relay対応）</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
body { font-family: sans-serif; margin:0; background:#f0f0f0; }
header { position: fixed; top:0; left:0; width:100%; background:#ddd; padding:6px 10px; z-index:100; display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
input { padding: 4px; font-size: 1em; width: 110px; }
button { padding: 4px 10px; font-size: 1em; }
.container { display:flex; gap:10px; margin-top:70px; padding:10px; }

.column { flex:1; border:1px solid #ccc; background:#fff; padding:8px; max-height:68vh; overflow-y:auto; }
#comment div { display:flex; align-items:center; margin-bottom:6px; }
#comment img { width:40px; height:40px; margin-right:8px; border-radius:4px; }
.giftItem { display:flex; align-items:center; background:#f9f9f9; padding:4px 6px; border-radius:6px; margin-bottom:6px; box-shadow:1px 1px 3px #aaa; }
.giftItem img { width:40px; height:40px; margin-right:8px; }
.column h2 { text-align:center; margin:6px 0; font-size:1.1em; }

#settingsPanel { display:none; position:absolute; right:10px; top:44px; background:#fff; border:1px solid #ccc; padding:8px; z-index:200; font-size:0.9em; box-shadow:0 2px 6px rgba(0,0,0,0.12); }
#settingsPanel div { margin-bottom:6px; }
.statusSmall { font-size:0.9em; color:#333; }
.smallNote { font-size:0.85em; color:#666; margin-left:6px; }
.tagComplement { color:#AA0000; font-weight:600; margin-right:6px; }
</style>
</head>
<body>

<header>
  <label>Room ID: <input type="text" id="roomInput" placeholder="例: 490133" value="490133"></label>
  <button id="switchRoom">表示切替</button>
  <button id="loadPastBtn">過去コメント取得</button>
  <span id="statusSpan" class="statusSmall">Status: 待機中</span>
  <span class="smallNote" id="connInfo">WS: relay</span>
  <span id="roomNameSpan" class="statusSmall">Room: -</span>
  <span id="startedSpan" class="statusSmall">開始: -</span>
  <span id="elapsedSpan" class="statusSmall">経過: -</span>

  <button id="toggleSettings" style="position:absolute; right:10px; top:6px;">設定</button>

  <div id="settingsPanel">
    <div><strong>コメント:</strong> 文字サイズ <input type="number" id="commentFontSize" value="14" min="10" max="30"> px
      色 <input type="color" id="commentColor" value="#000000"></div>
    <div><strong>有料ギフト:</strong> 文字サイズ <input type="number" id="paidFontSize" value="14" min="10" max="30"> px
      色 <input type="color" id="paidColor" value="#000000"></div>
    <div><strong>無料ギフト:</strong> 文字サイズ <input type="number" id="freeFontSize" value="14" min="10" max="30"> px
      色 <input type="color" id="freeColor" value="#000000"></div>
    <div style="display:flex; gap:6px;"><button id="applyDisplaySettings">適用</button><button id="clearComments">コメントクリア</button></div>
  </div>
</header>

<div class="container">
    <div class="column" id="colComment">
        <h2>コメント</h2>
        <div id="comment"></div>
    </div>
    <div class="column" id="colPaid">
        <h2>有料ギフト</h2>
        <div id="paidGift"></div>
    </div>
    <div class="column" id="colFree">
        <h2>無料ギフト</h2>
        <div id="freeGift"></div>
    </div>
</div>

<script>
/* ============================
   設定・状態変数
   ============================ */
const HEARTBEAT_INTERVAL = 10000; // ms: ブラウザ->Node ping 間隔
const COMMENT_CHECK_INTERVAL = 10000; // ms: API差分チェック間隔
const RECONNECT_BASE = 2000; // ms 初回再接続待ち
const RECONNECT_MAX = 30000; // ms 最大待ち時間

let broadcastKey = null;
let socket = null;
let socketUrl = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/ws`;
let wsConnected = false;
let hbTimer = null;
let commentCheckTimer = null;
let reconnectTimer = null;
let reconnectDelay = RECONNECT_BASE;
let startedAt = null;

/* UI要素 */
const statusSpan = document.getElementById('statusSpan');
const roomInput = document.getElementById('roomInput');
const roomNameSpan = document.getElementById('roomNameSpan');
const commentBox = document.getElementById('comment');
const paidBox = document.getElementById('paidGift');
const freeBox = document.getElementById('freeGift');

/* 表示設定 */
let commentSettings = {size:14, color:"#000000"};
let paidSettings = {size:14, color:"#000000"};
let freeSettings = {size:14, color:"#000000"};

/* WebSocketコメントバッファ（最新50件） */
let wsCommentBuffer = [];
function pushWsComment(c){
    wsCommentBuffer.unshift({
        id: c.cid || c.comment_id || null,
        text: (c.cm || c.comment || "").toString(),
        user: c.ac || c.name || "",
        ts: Date.now()
    });
    if(wsCommentBuffer.length > 200) wsCommentBuffer.pop();
}

/* ギフトマップ */
const paidGiftMap = {};
const freeGiftMap = {};

/* ============================
   DOM 表示関数
   ============================ */
function showComment(c, options = {}) {
    // c: {ac/name, cm/comment, av/avatar_id}
    const div = document.createElement('div');
    const img = document.createElement('img');
    img.src = `https://image.showroom-cdn.com/showroom-prod/image/avatar/${c.av || c.avatar_id || 0}.png`;
    img.onerror = ()=>{ img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw=='; }; // 空画像フォールバック
    const p = document.createElement('p');
    const tag = options.complement ? '<span class="tagComplement">★補完★</span> ' : '';
    p.innerHTML = `${tag}${escapeHtml((c.ac || c.name || ''))}：${escapeHtml((c.cm || c.comment || ''))}`;
    div.appendChild(img);
    div.appendChild(p);
    commentBox.prepend(div);
}

function showComplementComment(c){
    showComment(c, {complement: true});
}

function showGift(g) {
    const gt = parseInt(g.gt || 0);
    let container, map;
    if(gt === 2) { container = freeBox; map = freeGiftMap; }
    else { container = paidBox; map = paidGiftMap; }

    const key = `${g.u}_${g.g}`;
    if(map[key]){
        map[key].count += (g.n || 0);
        map[key].time = Date.now();
        map[key].div.querySelector('p').textContent = `${g.ac}：${map[key].count}個`;
        return;
    }
    const div = document.createElement('div');
    div.className = 'giftItem';
    const img1 = document.createElement('img');
    img1.src = `https://image.showroom-cdn.com/showroom-prod/image/avatar/${g.av||0}.png`;
    img1.onerror = ()=>{ img1.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw=='; };
    const img2 = document.createElement('img');
    img2.src = `https://static.showroom-live.com/image/gift/${g.g}_s.png?v=7`;
    img2.width = 36;
    const p = document.createElement('p');
    p.textContent = `${g.ac}：${g.n}個`;
    div.appendChild(img1);
    div.appendChild(img2);
    div.appendChild(p);
    container.prepend(div);
    map[key] = {div, count: g.n, time: Date.now()};
}

/* HTMLエスケープ（簡易） */
function escapeHtml(s){
    return (s||'').toString()
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#039;');
}

/* ============================
   WebSocket (ブラウザ -> Node/Relay) 管理
   ============================ */

function connectBrowserWS(){
    if(socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) return;
    statusSpan.textContent = 'Status: WS接続中...';
    socket = new WebSocket(socketUrl);

    socket.addEventListener('open', () => {
        wsConnected = true;
        statusSpan.textContent = 'Status: 接続済み';
        reconnectDelay = RECONNECT_BASE; // 接続復帰したら遅延リセット

        // 送信: ブロードキャストキーを渡して server.js に Showroom 接続を指示
        if(broadcastKey) {
            socket.send(JSON.stringify({ broadcast_key: broadcastKey }));
        }

        // ブラウザ->Node の心臓音（Ping）を開始
        startHeartbeat();
    });

    socket.addEventListener('message', (ev) => {
        // サーバーは2種類のメッセージを送る可能性がある：
        // 1) Showroom の生データ（文字列） -> we try parse JSON
        // 2) server-side hb/status objects (e.g. { hb: 123456 })
        let data = ev.data;
        // Try parse JSON wrapper first
        let parsed = null;
        try { parsed = JSON.parse(data); } catch(e){ parsed = null; }

        if(parsed && typeof parsed === 'object' && (parsed.hb || parsed.status || parsed.info)) {
            // server-side heartbeat/info -> 無害化（表示は不要）
            // 例: { hb: 123456 } や { status: "reconnected" }
            // optional: update UI
            if(parsed.status) statusSpan.textContent = `Status: ${parsed.status}`;
            return;
        }

        // If not control message, data might be Showroom raw message string forwarded by server.
        // Some relay servers forward the exact original string (which may include "MSG\t<key>...").
        if(typeof data === 'string') {
            // If server forwarded JSON string already, try parse
            let obj = null;
            try {
                obj = JSON.parse(data);
            } catch(e){
                // Try remove "MSG\t<key>" prefix if present
                try {
                    const prefixPattern = /^MSG\t[^\t]+\t?/;
                    const stripped = data.replace(prefixPattern, '');
                    obj = JSON.parse(stripped);
                } catch(e2) {
                    // cannot parse -> ignore
                    console.debug('受信済み非JSONデータ', data);
                    return;
                }
            }
            // obj now is parsed Showroom object
            if(obj) {
                // comment
                if(obj.cm){
                    showComment({ ac: obj.ac, cm: obj.cm, av: obj.av });
                    pushWsComment({ cid: obj.cid || obj.comment_id, cm: obj.cm, ac: obj.ac });
                }
                // gift
                else if(obj.g){
                    showGift(obj);
                }
                // room meta
                if(obj.main_name) { roomNameSpan.textContent = 'Room: ' + obj.main_name; }
                if(!startedAt && obj.started_at) { startedAt = obj.started_at * 1000; }
            }
        }
    });

    socket.addEventListener('close', () => {
        wsConnected = false;
        statusSpan.textContent = 'Status: 切断';
        stopHeartbeat();
        scheduleReconnect();
    });

    socket.addEventListener('error', (err) => {
        console.error('WS error', err);
        // wait for close event to schedule reconnect
    });
}

/* 心拍（ブラウザ -> Node） */
function startHeartbeat(){
    stopHeartbeat();
    hbTimer = setInterval(() => {
        if(socket && socket.readyState === WebSocket.OPEN){
            // minimal ping to let relay/server know we're alive
            try { socket.send(JSON.stringify({ type: 'ping', t: Date.now() })); }
            catch(e){ console.warn('ping send failed', e); }
        }
    }, HEARTBEAT_INTERVAL);
}
function stopHeartbeat(){
    if(hbTimer){ clearInterval(hbTimer); hbTimer = null; }
}

/* 自動再接続 (指数バックオフ) */
function scheduleReconnect(){
    if(reconnectTimer) return;
    const delay = Math.min(reconnectDelay, RECONNECT_MAX);
    console.log(`WS 再接続 ${delay}ms 後`);
    reconnectTimer = setTimeout(()=>{
        reconnectTimer = null;
        reconnectDelay = Math.min(reconnectDelay * 1.8, RECONNECT_MAX);
        connectBrowserWS();
    }, delay);
}

/* ============================
   過去コメント取得（Node経由） + 差分補完
   ============================ */

async function loadPastComments(roomId, showAll=false){
    if(!roomId) return;
    try{
        const res = await fetch(`/comment_log?room_id=${roomId}`);
        const logs = await res.json();
        if(!Array.isArray(logs)) {
            console.warn('過去コメントAPIが配列を返さない', logs);
            return;
        }
        // 表示：ログ全件 or 最新10件（テスト向けは最新10件）
        const items = showAll ? logs : logs.slice(-10);
        // show in chronological order: older -> newer, so we iterate items in order and prepend to have newest on top
        for(const log of items){
            const mapped = { name: log.name, comment: log.comment, avatar_id: log.avatar_id };
            // push to buffer and display, but avoid double display if recent WS already included it:
            const exists = wsCommentBuffer.some(ws => {
                if(ws.id && log.comment_id && ws.id === log.comment_id) return true;
                if(ws.text === log.comment && ws.user === log.name) return true;
                return false;
            });
            if(!exists){
                showComment({ ac: mapped.name, cm: mapped.comment, av: mapped.avatar_id });
                pushWsComment({ cid: log.comment_id, cm: log.comment, ac: log.name });
            }
        }
    } catch(e){
        console.error('過去コメント取得失敗', e);
    }
}

/* Periodic check to compare latest 10 comments and補完表示 */
async function checkMissingComments(){
    const roomId = roomInput.value.trim();
    if(!roomId) return;
    try{
        const res = await fetch(`/comment_log?room_id=${encodeURIComponent(roomId)}`);
        const logs = await res.json();
        if(!Array.isArray(logs)) return;
        const latest = logs.slice(-10);
        latest.forEach(log => {
            const exists = wsCommentBuffer.some(ws => {
                if(ws.id && log.comment_id && ws.id === log.comment_id) return true;
                if(ws.text === log.comment && ws.user === log.name) return true;
                return false;
            });
            if(!exists){
                const c = { name: log.name, comment: log.comment, avatar_id: log.avatar_id };
                showComplementComment({ name: c.name, comment: c.comment, avatar_id: c.avatar_id });
                pushWsComment({ cid: log.comment_id, cm: log.comment, ac: log.name });
            }
        });
    } catch(e){
        console.error('log check failed', e);
    }
}

/* ============================
   イベントバインド & 初期化
   ============================ */

document.getElementById('toggleSettings').onclick = () => {
    const panel = document.getElementById('settingsPanel');
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
};

document.getElementById('applyDisplaySettings').onclick = () => {
    commentSettings.size = parseInt(document.getElementById('commentFontSize').value);
    commentSettings.color = document.getElementById('commentColor').value;
    paidSettings.size = parseInt(document.getElementById('paidFontSize').value);
    paidSettings.color = document.getElementById('paidColor').value;
    freeSettings.size = parseInt(document.getElementById('freeFontSize').value);
    freeSettings.color = document.getElementById('freeColor').value;

    commentBox.style.fontSize = commentSettings.size + 'px';
    commentBox.style.color = commentSettings.color;
    paidBox.style.fontSize = paidSettings.size + 'px';
    paidBox.style.color = paidSettings.color;
    freeBox.style.fontSize = freeSettings.size + 'px';
    freeBox.style.color = freeSettings.color;
};

document.getElementById('clearComments').onclick = () => {
    commentBox.innerHTML = '';
    wsCommentBuffer = [];
};

document.getElementById('loadPastBtn').onclick = async () => {
    const roomId = roomInput.value.trim();
    if(!roomId) return alert('Room ID を入力してください');
    await loadPastComments(roomId, false); // 最新10件だけ表示
};

/* ルーム切替 */
document.getElementById('switchRoom').onclick = async () => {
    const roomId = roomInput.value.trim();
    if(!roomId) return alert('Room ID を入力してください');

    // fetch broadcast_key from server (node)
    try{
        const res = await fetch(`/get_broadcast_key?room_id=${encodeURIComponent(roomId)}`);
        const json = await res.json();
        if(!json.broadcast_key) { alert('broadcast_key取得失敗'); return; }
        broadcastKey = json.broadcast_key;

        // reset local UI/buffer
        commentBox.innerHTML = '';
        paidBox.innerHTML = '';
        freeBox.innerHTML = '';
        wsCommentBuffer = [];
        Object.keys(paidGiftMap).forEach(k=>delete paidGiftMap[k]);
        Object.keys(freeGiftMap).forEach(k=>delete freeGiftMap[k]);
        startedAt = null;
        roomNameSpan.textContent = 'Room: -';

        // ensure socket connected and send broadcast_key
        connectBrowserWS();
        if(socket && socket.readyState === WebSocket.OPEN){
            socket.send(JSON.stringify({ broadcast_key: broadcastKey }));
        }

        // load past comments immediately
        await loadPastComments(roomId, false);

        // start periodic comment check if not started
        if(!commentCheckTimer){
            commentCheckTimer = setInterval(checkMissingComments, COMMENT_CHECK_INTERVAL);
        }
    } catch(e){
        console.error(e);
        alert('broadcast_key取得中にエラー');
    }
};

/* 初期自動接続（初期 room を設定している場合） */
(function init() {
    connectBrowserWS();
    // start periodic check (will return early if no room)
    if(!commentCheckTimer) commentCheckTimer = setInterval(checkMissingComments, COMMENT_CHECK_INTERVAL);
})();

</script>
</body>
</html>
